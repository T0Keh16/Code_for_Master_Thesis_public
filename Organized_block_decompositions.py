import math
import sympy
import numpy as np
import itertools
from matplotlib import pyplot as plt
import networkx as nx
from matplotlib.patches import ConnectionPatch
import matplotlib.patches as mpatches
import gudhi


# assumes that list1, list2 have same number of entries, no check if not the case
# or that list1 or list2 is zero or infinity
def is_leq_lists(list1, list2):
    # everything is at most oo
    if set(list2) == {sympy.oo}:
        return True
    # everything is at least 0
    if set(list1) == {0}:
        return True
    # only 0 is less than or equal to 0
    if set(list2) == {0}:
        return set(list1) == {0}
    # compare componentwise
    # if an element of list1 is bigger than the corresponding element in list2, then list1 !< list2
    for i in range(len(list1)):
        if list1[i] > list2[i]:
            return False
    return True


def min_of_lists(list1, list2):
    return [min(list1[i], list2[i]) for i in range(len(list1))]


def max_of_lists(list1, list2):
    #maximum = []
    #for i in range(len(list1)):
    #    maximum.append(max(list1[i], list2[i]))
    #return maximum
    return [max(list1[i], list2[i]) for i in range(len(list1))]


# incomplete
def lex_sort(list, key=None):
    #for i in
    return True


def has_empty_or_zero_generator(G):
    decomposition = []
    if len(G) == 0:
        decomposition.append(sympy.Matrix([[sympy.oo], [0]]))
    elif len(G) == 1:
        if set(G[0]) == {0}:
            decomposition.append(sympy.Matrix([G[0], G[0]]))
    else:
        return False
    return decomposition


# old
def organized_decomposition2(G, sorting_order=False):
    # todo add option to select monomial order and extension direction (sigma and pi)
    # if G is generated by one element, check if this is zero
    if len(G) == 1:
        if set(G[0]) == {0}:
            zeroblock = [sympy.Matrix([G[0], G[0]])]
            return zeroblock
    # 10.2.2 and 10.2.3
    # create list of inner corners of elementary decomposition of L
    # 3.1.1
    n = len(G[0])
    L = [[0] for i in range(n)]
    for m in G:
        for i in range(n):
            L[i].append(m[i])
    # 3.1.2
    L = [list(set(x)) for x in L]
    # 3.1.3
    inner_corners = list(itertools.product(*L))
    # 3.1.4
    for m in G:
        inner_corners = [x for x in inner_corners if not is_leq_lists(m, x)]
    # sort inner corners (default is lexsort with 0-th, then 1-st, then 2-nd ...)
    # if no sorting order is specified, then use default
    # todo improve sorting algorithm
    if not sorting_order:
        sorting_order = tuple((n-i-1 for i in range(n)))
    #    print(sorting_order)
    temp_sorting_indices = []
    #for i in range(n):
    #    temp_sorting_indices.append([corner[i] for corner in inner_corners])
    #temp_sorting_indices = [temp_sorting_indices[i] for i in sorting_order]
    #ind = np.lexsort(tuple(temp_sorting_indices))
    #inner_corners = [inner_corners[i] for i in ind]
    #print(inner_corners)
    inner_corners.sort()
    # 3.1.5
    outer_corners = []
    for corner in inner_corners:
        b = []
        for i in range(n):
            if corner[i] != L[i][-1]:
                b.append(L[i][L[i].index(corner[i])+1]-1)
            else:
                b.append(sympy.oo)
        outer_corners.append(b)
    # 10.2.4
    block_list = []
    # 10.2.5
    k = 1
    used_inner_corners = []
    used_outer_corners = []
    while inner_corners:
        # 10.2.5.a
        a = inner_corners[0]
        # 10.2.5.b, proceed by alg 9.3
        # begin 9.3
        # 9.3.1
        b_k = list(a)
        a = list(a)
        # 9.3.2
        # a^k in paper is a here
        H_k = []
        # index j is shifted -1 relative to the paper
        for j in range(1, k-1):
            p_jk = max_of_lists(used_inner_corners[j], a)
            if is_leq_lists(p_jk, used_outer_corners[j]):
                print('p = ', p_jk, used_outer_corners[j])
                H_k.append(p_jk)
        print('H_k = ', H_k)
        print('G = ', G)
        G_k = G + H_k
        print('G_k = ', G_k)
        # 9.3.3
        for h in range(n):
            # 9.3.3.a only create b_h^k(oo)
            b_hk_infty = []
            for i in range(n):
                if i == h:
                    b_hk_infty.append(sympy.oo)
                else:
                    b_hk_infty.append(b_k[i])
            # 9.3.3.b
            G_hk = []
            for x in G_k:
                if is_leq_lists(x, b_hk_infty):
                    G_hk.append(x)
            print('G_hk = ', G_hk)
            # 9.3.3.c and d
            if G_hk == []:
                t_star = sympy.oo
            else:
                print(G_hk, h)
                t_star = min([m_l[h] for m_l in G_hk]) - 1
            #print(t_star)
            b_k[h] = t_star
        # 9.3.4
        B = sympy.Matrix([b_k, a])
        print(B)
        # end 9.3
        # 10.2.5.c
        block_list.append(B)
        used_inner_corners.append(a)
        used_outer_corners.append(b_k)
        # 10.2.5.d
        for corner in inner_corners:
            if is_leq_lists(corner, b_k):
                if is_leq_lists(a, corner):
                    outer_corners.remove(outer_corners[inner_corners.index(corner)])
                    inner_corners.remove(corner)
        k += 1
    # 10.2.6
    return block_list


def elementary_decomposition(G):
    elem_decomp = []
    zero_decomp = has_empty_or_zero_generator(G)
    if zero_decomp:
        return zero_decomp
    #if len(G) == 1:
    #    if set(G[0]) == {0}:
    #        infinities = tuple([sympy.oo for i in range(len(G[0]))])
    #        zeroblock = [sympy.Matrix([infinities, G[0]])]
    #        return zeroblock
    n = len(G[0])
    L = [[0] for i in range(n)]
    for m in G:
        for i in range(n):
            L[i].append(m[i])
    # 3.1.2
    L = [list(set(x)) for x in L]
    # 3.1.3
    inner_corners = list(itertools.product(*L))
    # 3.1.4
    for m in G:
        inner_corners = [x for x in inner_corners if not is_leq_lists(m, x)]
    inner_corners.sort()
    # print(inner_corners)
    # inner_corners.sort()
    # 3.1.5
    outer_corners = []
    for corner in inner_corners:
        b = []
        for i in range(n):
            if corner[i] != L[i][-1]:
                b.append(L[i][L[i].index(corner[i]) + 1] - 1)
            else:
                b.append(sympy.oo)
        outer_corners.append(b)
    for oc, ic in zip(outer_corners, inner_corners):
        elem_decomp.append(sympy.Matrix((oc, ic)))
    return elem_decomp


def organized_decomposition(G, sorting_order=False):
    # todo add option to select monomial order and extension direction (sigma and pi)
    # if G is generated by one element, check if this is zero
    zero_decomp = has_empty_or_zero_generator(G)
    if zero_decomp:
        return zero_decomp
    # 10.2.2 and 10.2.3
    # create list of inner corners of elementary decomposition of L
    # 3.1.1
    n = len(G[0])
    L = [[0] for i in range(n)]
    for m in G:
        for i in range(n):
            L[i].append(m[i])
    # 3.1.2
    L = [list(set(x)) for x in L]
    # 3.1.3
    inner_corners = list(itertools.product(*L))
    # 3.1.4
    for m in G:
        inner_corners = [x for x in inner_corners if not is_leq_lists(m, x)]
    # sort inner corners (default is lexsort with 0-th, then 1-st, then 2-nd ...)
    # if no sorting order is specified, then use default
    # todo improve sorting algorithm
    if not sorting_order:
        sorting_order = tuple((i for i in range(n)))
    #print(sorting_order)
    temp_sorting_indices = []
    for i in range(n):
        temp_sorting_indices.append([corner[i] for corner in inner_corners])
    temp_sorting_indices = [temp_sorting_indices[i] for i in sorting_order]
    ind = np.lexsort(tuple(temp_sorting_indices))
    inner_corners = [inner_corners[i] for i in ind]
    #print(inner_corners)
    #inner_corners.sort()
    # 3.1.5
    outer_corners = []
    for corner in inner_corners:
        b = []
        for i in range(n):
            if corner[i] != L[i][-1]:
                b.append(L[i][L[i].index(corner[i])+1]-1)
            else:
                b.append(sympy.oo)
        outer_corners.append(b)
    # 10.2.4
    block_list = []
    # 10.2.5
    k = 1
    used_inner_corners = []
    used_outer_corners = []
    while inner_corners:
        # 10.2.5.a
        a = list(inner_corners[0])
        # 10.2.5.b, proceed by alg 9.3
        # begin 9.3
        # 9.3.1
        b_k = a.copy()
        #a = list(a)
        # 9.3.2
        # a^k in paper is a here
        H_k = []
        # index j is shifted -1 relative to the paper
        for j in range(1, k-1):
            p_jk = max_of_lists(used_inner_corners[j], a)
            if is_leq_lists(p_jk, used_outer_corners[j]):
                H_k.append(p_jk)
        G_k = G + H_k
        # 9.3.3
        for h in range(n):
            b_hk_infty = b_k.copy()
            b_hk_infty[h] = sympy.oo
            G_hk = []
            for x in G_k:
                if is_leq_lists(x, b_hk_infty):
                    G_hk.append(x)
            # 9.3.3.c and d
            if G_hk == []:
                t_star = sympy.oo
            else:
                t_star = min([m_l[h] for m_l in G_hk]) - 1
            b_k[h] = t_star
        # 9.3.4
        B = sympy.Matrix([b_k, a])
        # end 9.3
        # 10.2.5.c
        block_list.append(B)
        used_inner_corners.append(a)
        used_outer_corners.append(b_k)
        # 10.2.5.d
        duplicate_inner_corners = []
        duplicate_outer_corners = []
        for corner in inner_corners:
            if is_leq_lists(corner, b_k):
                if is_leq_lists(a, corner):
                    duplicate_inner_corners.append(corner)
                    duplicate_outer_corners.append(outer_corners[inner_corners.index(corner)])
        for corner in duplicate_inner_corners:
            inner_corners.remove(corner)
        for corner in duplicate_outer_corners:
            outer_corners.remove(corner)
        k += 1
    # 10.2.6
    return block_list


def plot_upperset(G):
    G.sort()
    xpoints = []
    ypoints = []
    for corner in G:
        xpoints.append(corner[0])
        ypoints.append(corner[1])
        if len(G) != 1:
            if G.index(corner) != len(G)-1:
                xpoints.append(G[G.index(corner)+1][0])
                ypoints.append(corner[1])
    fig = plt.plot(xpoints, ypoints)
    color = fig[0].get_color()
    (ymin, ymax) = plt.gca().axes.get_ylim()
    (xmin, xmax) = plt.gca().axes.get_xlim()
    plt.plot([G[0][0], G[0][0]], [G[0][1], ymax], c=color)
    plt.plot([G[-1][0], xmax], [G[-1][1], G[-1][1]], c=color)


def create_tree(ideals, label=False):
    g = nx.Graph()
    xpoints = []
    ypoints = []
    annotations_i = []
    annotations_o = []
    decompositions = [organized_decomposition(I) for I in ideals]
    k = 0
    for block in decompositions[0]:
        xpoints.append(0)
        ypoints.append(decompositions[0].index(block))
        annotations_i.append(tuple(block.row(1)))
        annotations_o.append(tuple(block.row(0)))
    plt.plot(xpoints, ypoints, 'o')
    if label:
        for xi, yi, text_i, text_o in zip(xpoints, ypoints, annotations_i, annotations_o):
            plt.annotate(text_i,
                         xy=(xi, yi), xycoords='data',
                         xytext=(1.5, 1.5), textcoords='offset points')
            #plt.annotate(text_o,
            #             xy=(xi, yi), xycoords='data',
            #             xytext=(1.5, 3), textcoords='offset points')
    while decompositions:
        if len(decompositions) == 1:
            break
        blocks_0 = decompositions[0]
        inner_corners_0 = [block.row(1) for block in blocks_0]
        blocks_1 = decompositions[1]
        for corner in inner_corners_0:
            for block in blocks_1:
                if is_leq_lists(corner, block.row(0)) and is_leq_lists(block.row(1), corner):
                    plt.plot([k, k + 1], [inner_corners_0.index(corner), blocks_1.index(block)])
        xpoints = []
        ypoints = []
        annotations = []
        for block in blocks_1:
            xpoints.append(k+1)
            ypoints.append(blocks_1.index(block))
            annotations.append(tuple(block.row(1)))
        plt.plot(xpoints, ypoints, 'o')
        if label:
            for xi, yi, text in zip(xpoints, ypoints, annotations):
                plt.annotate(text,
                            xy=(xi, yi), xycoords='data',
                            xytext=(1.5, 1.5), textcoords='offset points')
        decompositions.pop(0)
        k += 1
    plt.show()


# create graph that is labeled and/or directed with networkx
# if ideals is ordered by reverse inclusion, then all vertices will have a path to final layer
def create_tree_2(ideals, label=False, directed=False, arrowstyle='-|>', color_scheme='tab10', colored=False, all_ideals=False,
                  sorting_order=False, extension_order=False, decomp_type='elementary', legend=True):
    # todo add option for different vertex color for each ideal
    # this color should be first appearance of vertex in any ideal
    if directed:
        g = nx.DiGraph()
    else:
        g = nx.Graph()
    decompositions = [eval(decomp_type + f'_decomposition({I})') for I in ideals]
    nr_of_decomps = len(decompositions)
    #node_colors = []
    #for decomp in decompositions:
    #    node_colors.append(plt.colormaps('Set2'))
    decompindex = 0
    for decomposition in decompositions:
        for block in decomposition:
            if all_ideals:
                g.add_node((tuple(block.row(1)), decompindex), blockindex=decompindex)
            else:
                if tuple(block.row(1)) not in g.nodes():
                    g.add_node(tuple(block.row(1)), blockindex=decompindex)
                else:
                    g.add_node(tuple(block.row(1)))
        decompindex += 1
    #print(g.nodes(data=True))
    k = 0
    while decompositions:
        if len(decompositions) == 1:
            break
        blocks_0 = decompositions[0]
        inner_corners_0 = [block.row(1) for block in blocks_0]
        blocks_1 = decompositions[1]
        for corner in inner_corners_0:
            for block in blocks_1:
                if all_ideals:
                    if is_leq_lists(corner, block.row(0)) and is_leq_lists(block.row(1), corner):
                        g.add_edge((tuple(corner), k), (tuple(block.row(1)), k+1))
                else:
                    if is_leq_lists(corner, block.row(0)) and is_leq_lists(block.row(1), corner):
                        g.add_edge(tuple(corner), tuple(block.row(1)))
        decompositions.pop(0)
        k += 1
    #print(g.edges())
    #print(g.nodes(data=True))
    #node_colors = [g.nodes[node]['blockindex'] for node in list(g.nodes())]
    node_colors2 = [plt.cm.tab10(g.nodes[node]['blockindex']) for node in list(g.nodes())]
    #print(node_colors)
    # draw the graph
    if not directed:
        nx.draw(g, with_labels=label)
    else:
        #pos = nx.planar_layout(g)
        pos = nx.planar_layout(g)
        nodes = nx.draw_networkx_nodes(g, pos, node_color=node_colors2)
        #nodes = nx.draw_networkx_nodes(g, pos, node_color=node_colors, cmap=plt.cm.tab10)
        if label:
            labels = nx.draw_networkx_labels(g, pos)
        edges = nx.draw_networkx_edges(
            g,
            pos,
            arrowstyle=arrowstyle,
            arrowsize=10,
            width=1,
        )
        if legend:
            handles = [mpatches.Patch(label=f'ideal{i}', facecolor=plt.cm.tab10(i)) for i in range(nr_of_decomps)]
            plt.legend(handles=handles)
    plt.show()


#10.3 (should be (oo oo 0;0 0 0),(oo 0 oo;0 0 1),(0 oo oo;0 1 1))
#print(organized_decomposition([[1,0,9],[1,5,0],[7,0,0]]))
#10.5 (should be (6 4 8;0 0 0), (0 oo oo;0 0 9), (0 oo 8;0 5 0))
#print(organized_decomposition([[1,1,1]]))
#10.6
#print(organized_decomposition([[1,1,0,0],[1,0,1,0],[1,0,0,1],[0,1,1,1]]))

ideal1 = [[6,10],[4,11],[7,8],[12,6],[14,3]]
ideal2 = [[3,9],[4,7],[7,5],[9,1]]
ideal3 = [[2,5],[4,4],[5,0]]

ideal21 = [[3,7],[5,4]]
ideal22 = [[1,6],[2,5],[4,2]]
ideal23 = [[0,4],[3,1]]


cpx1 = [[1,1,0],[1,0,1],[0,1,1]]
cpx2 = [[1,0,1],[0,1,1]]
cpx3 = [[1,0,1]]
cpx4 = [(1,1,1)]
cpx5 = []

cpx00 = [[1,1,1,1]]
cpx01 = [[1,0,1,0],[1,1,0,1],[0,1,1,1]]
cpx02 = [[0,1,0,1],[1,0,1,0]]

create_tree_2([cpx1,cpx2,cpx3,cpx4], label=True, directed=True, all_ideals=True, decomp_type='elementary')
create_tree_2([cpx1,cpx2,cpx3,cpx4,cpx5], label=False, directed=True, all_ideals=False)
#create_tree_2([cpx5,cpx4,cpx3,cpx2,cpx1], label=True, directed=True, all_ideals=True, decomp_type='elementary')
#create_tree_2([cpx5,cpx4,cpx3,cpx2,cpx1], label=True, directed=True, all_ideals=True, decomp_type='organized')
#create_tree_2([cpx5,cpx4,cpx3,cpx2,cpx1], label=False, directed=True, all_ideals=False)
#create_tree([cpx1,cpx2,cpx3,cpx4,cpx5], label=True)
#create_tree_2([cpx00, cpx01, cpx02], label=True, directed=True)
#create_tree([cpx00, cpx01, cpx02], label=True)
#create_tree([cpx02, cpx01, cpx00])
#create_tree([cpx1,cpx2,cpx3,cpx4,cpx5])
#create_tree([cpx5,cpx4,cpx3,cpx2,cpx1])
#create_tree_2([ideal1, ideal2, ideal3], directed=True, label=True, sorting_order=(1,0), all_ideals=True)
#create_tree_2([ideal1, ideal2, ideal3], directed=True, label=True, sorting_order=(0,1), all_ideals=True)
#create_tree([ideal1, ideal2, ideal3], label=True)
#create_tree_2([ideal3, ideal2, ideal1], directed=True, label=True)
#create_tree([ideal3, ideal2, ideal1], label=True)
#print(elementary_decomposition(ideal3))

plt.axhline(0, color='k')
plt.axvline(0, color='k')
plot_upperset(ideal21)
plot_upperset(ideal22)
plot_upperset(ideal23)
plt.show()

