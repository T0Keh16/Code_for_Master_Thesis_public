import math
import sympy
import numpy as np
import itertools
from matplotlib import pyplot as plt
import networkx as nx
from matplotlib.patches import ConnectionPatch
import matplotlib.patches as mpatches
import gudhi


# checks if lists/tuples are smaller in pointwise-comparison order
def is_leq_lists(list1, list2):
    # everything is at most oo
    if set(list2) == {sympy.oo}:
        return True
    # everything is at least 0
    if set(list1) == {0}:
        return True
    # only 0 is less than or equal to 0
    if set(list2) == {0}:
        return set(list1) == {0}
    # if the lists/tuples don't have the same number of entries, don't continue
    # this should only be considered if lists/tuples aren't trivial
    if len(list1) != len(list2):
        raise IndexError("The lists don't have the same number of entries")
    # compare componentwise
    # if an element of list1 is bigger than the corresponding element in list2, then list1 !< list2
    for i in range(len(list1)):
        if list1[i] > list2[i]:
            return False
    return True


# returns pointwise minimum of lists
def min_of_lists(list1, list2):
    return [min(list1[i], list2[i]) for i in range(len(list1))]


# returns pointwise maximum of lists
def max_of_lists(list1, list2):
    return [max(list1[i], list2[i]) for i in range(len(list1))]


def lex_sort(list, key=None):
    #for i in
    return True


# checks whether generator of upper-set is empty (ideal is zero) or 0 (ideal is the entire ring)
def has_empty_or_zero_generator(G):
    decomposition = []
    # empty generating set corresponds to ideal being zero
    if len(G) == 0:
        decomposition.append(sympy.Matrix([[sympy.oo], [0]]))
    # zero generating set corresponds to ideal being generated by 1
    elif len(G) == 1:
        if set(G[0]) == {0}:
            decomposition.append(sympy.Matrix([G[0], G[0]]))
    else:
        return False
    return decomposition


def elementary_decomposition(G):
    elem_decomp = []
    zero_decomp = has_empty_or_zero_generator(G)
    if zero_decomp:
        return zero_decomp
    n = len(G[0])
    L = [[0] for i in range(n)]
    for m in G:
        for i in range(n):
            L[i].append(m[i])
    # 3.1.2
    L = [list(set(x)) for x in L]
    # 3.1.3
    inner_corners = list(itertools.product(*L))
    # 3.1.4
    for m in G:
        inner_corners = [x for x in inner_corners if not is_leq_lists(m, x)]
    inner_corners.sort()
    # 3.1.5
    outer_corners = []
    for corner in inner_corners:
        b = []
        for i in range(n):
            if corner[i] != L[i][-1]:
                b.append(L[i][L[i].index(corner[i]) + 1] - 1)
            else:
                b.append(sympy.oo)
        outer_corners.append(b)
    for oc, ic in zip(outer_corners, inner_corners):
        elem_decomp.append(sympy.Matrix((oc, ic)))
    return elem_decomp


def organized_decomposition(G, sorting_order=False):
    # todo add option to select monomial order and extension direction (sigma and pi)
    # if G is generated by one element, check if this is zero
    zero_decomp = has_empty_or_zero_generator(G)
    if zero_decomp:
        return zero_decomp
    # 10.2.2 and 10.2.3
    # create list of inner corners of elementary decomposition of L
    # 3.1.1
    n = len(G[0])
    L = [[0] for i in range(n)]
    for m in G:
        for i in range(n):
            L[i].append(m[i])
    # 3.1.2
    L = [list(set(x)) for x in L]
    # 3.1.3
    inner_corners = list(itertools.product(*L))
    # 3.1.4
    for m in G:
        inner_corners = [x for x in inner_corners if not is_leq_lists(m, x)]
    # sort inner corners (default is lexsort with 0-th, then 1-st, then 2-nd ...)
    # if no sorting order is specified, then use default
    # todo improve sorting algorithm
    if not sorting_order:
        sorting_order = tuple((i for i in range(n)))
    #print(sorting_order)
    temp_sorting_indices = []
    for i in range(n):
        temp_sorting_indices.append([corner[i] for corner in inner_corners])
    temp_sorting_indices = [temp_sorting_indices[i] for i in sorting_order]
    ind = np.lexsort(tuple(temp_sorting_indices))
    inner_corners = [inner_corners[i] for i in ind]
    #print(inner_corners)
    #inner_corners.sort()
    # 3.1.5
    outer_corners = []
    for corner in inner_corners:
        b = []
        for i in range(n):
            if corner[i] != L[i][-1]:
                b.append(L[i][L[i].index(corner[i])+1]-1)
            else:
                b.append(sympy.oo)
        outer_corners.append(b)
    # 10.2.4
    block_list = []
    # 10.2.5
    k = 1
    used_inner_corners = []
    used_outer_corners = []
    while inner_corners:
        # 10.2.5.a
        a = list(inner_corners[0])
        # 10.2.5.b, proceed by alg 9.3
        # begin 9.3
        # 9.3.1
        b_k = a.copy()
        #a = list(a)
        # 9.3.2
        # a^k in paper is a here
        H_k = []
        # index j is shifted -1 relative to the paper
        for j in range(1, k-1):
            p_jk = max_of_lists(used_inner_corners[j], a)
            if is_leq_lists(p_jk, used_outer_corners[j]):
                H_k.append(p_jk)
        G_k = G + H_k
        # 9.3.3
        for h in range(n):
            b_hk_infty = b_k.copy()
            b_hk_infty[h] = sympy.oo
            G_hk = []
            for x in G_k:
                if is_leq_lists(x, b_hk_infty):
                    G_hk.append(x)
            # 9.3.3.c and d
            if G_hk == []:
                t_star = sympy.oo
            else:
                t_star = min([m_l[h] for m_l in G_hk]) - 1
            b_k[h] = t_star
        # 9.3.4
        B = sympy.Matrix([b_k, a])
        # end 9.3
        # 10.2.5.c
        block_list.append(B)
        used_inner_corners.append(a)
        used_outer_corners.append(b_k)
        # 10.2.5.d
        duplicate_inner_corners = []
        duplicate_outer_corners = []
        for corner in inner_corners:
            if is_leq_lists(corner, b_k):
                if is_leq_lists(a, corner):
                    duplicate_inner_corners.append(corner)
                    duplicate_outer_corners.append(outer_corners[inner_corners.index(corner)])
        for corner in duplicate_inner_corners:
            inner_corners.remove(corner)
        for corner in duplicate_outer_corners:
            outer_corners.remove(corner)
        k += 1
    # 10.2.6
    return block_list


# create graph that is labeled and/or directed using networkx
# if ideals is ordered by reverse inclusion, then all vertices will have a path to final layer
def create_tree_3(filtration, label=False, directed=False, arrowstyle='-|>', color_scheme='tab10', colored=False, all_ideals=False,
                  sorting_order=False, extension_order=False, decomp_type='elementary', legend=True, return_graph=False, graph_type='overlap'):
    # todo add option for different vertex color for each ideal
    # this color should be first appearance of vertex in any ideal
    if directed:
        g = nx.DiGraph()
    else:
        g = nx.Graph()
    decompositions = [eval(decomp_type + f'_decomposition({I})') for I in filtration]
    nr_of_decomps = len(decompositions)
    decompindex = 0
    for decomposition in decompositions:
        for block in decomposition:
            if all_ideals:
                g.add_node((tuple(block.row(1)), decompindex), blockindex=decompindex)
            else:
                if tuple(block.row(1)) not in g.nodes():
                    g.add_node(tuple(block.row(1)), blockindex=decompindex)
                else:
                    g.add_node(tuple(block.row(1)))
        decompindex += 1
    k = 0
    while decompositions:
        if len(decompositions) == 1:
            break
        blocks_0 = decompositions[0]
        blocks_1 = decompositions[1]
        for block_0 in blocks_0:
            for block_1 in blocks_1:
                if graph_type == 'overlap':
                    if all_ideals:
                        # check if block_0 and block_1 overlap by comparing inner corners and outer corners
                        if is_leq_lists(block_0.row(1), block_1.row(0)) and is_leq_lists(block_1.row(1), block_0.row(0)):
                            g.add_edge((tuple(block_0.row(1)), k), (tuple(block_1.row(1)), k + 1))
                    else:
                        if is_leq_lists(block_0.row(1), block_1.row(0)) and is_leq_lists(block_1.row(1), block_0.row(0)):
                            g.add_edge(tuple(block_0.row(1)), tuple(block_1.row(1)))
                if graph_type == 'inner_corners':
                    corner = block_0.row(1)
                    block = block_1
                    if all_ideals:
                        if is_leq_lists(corner, block.row(0)) and is_leq_lists(block.row(1), corner):
                            g.add_edge((tuple(corner), k), (tuple(block.row(1)), k + 1))
                    else:
                        if is_leq_lists(corner, block.row(0)) and is_leq_lists(block.row(1), corner):
                            g.add_edge(tuple(corner), tuple(block.row(1)))
        decompositions.pop(0)
        k += 1
    if return_graph:
        return (g)
    node_colors2 = [plt.cm.tab10(g.nodes[node]['blockindex']) for node in list(g.nodes())]
    # draw the graph
    if not directed:
        nx.draw(g, with_labels=label)
    else:
        pos = nx.spring_layout(g)
        nodes = nx.draw_networkx_nodes(g, pos, node_color=node_colors2)
        if label:
            labels = nx.draw_networkx_labels(g, pos)
        edges = nx.draw_networkx_edges(
            g,
            pos,
            arrowstyle=arrowstyle,
            arrowsize=10,
            width=1,
        )
        if legend:
            handles = [mpatches.Patch(label=f'ideal {i+1}', facecolor=plt.cm.tab10(i)) for i in range(nr_of_decomps)]
            plt.legend(handles=handles)
    plt.show()



#10.3 (should be (oo oo 0;0 0 0),(oo 0 oo;0 0 1),(0 oo oo;0 1 1))
#print(organized_decomposition([[1,0,9],[1,5,0],[7,0,0]]))
#10.5 (should be (6 4 8;0 0 0), (0 oo oo;0 0 9), (0 oo 8;0 5 0))
#print(organized_decomposition([[1,1,1]]))
#10.6
#print(organized_decomposition([[1,1,0,0],[1,0,1,0],[1,0,0,1],[0,1,1,1]]))


ideal1 = [[6,10],[4,11],[7,8],[12,6],[14,3]]
ideal2 = [[3,9],[4,7],[7,5],[9,1]]
ideal3 = [[2,5],[4,4],[5,0]]

ideal_filtration = [ideal1, ideal2, ideal3]
reverse_ideal_filtration = [ideal3, ideal2, ideal1]

ideal21 = [[3,7],[5,4]]         # blue
ideal22 = [[1,6],[2,5],[4,2]]   # orange
ideal23 = [[0,4],[3,1]]         # green
new_ideals = [ideal23, ideal22, ideal21]


cpx1 = [[1,1,0],[1,0,1],[0,1,1]]
cpx2 = [[1,0,1],[0,1,1]]
cpx3 = [[1,0,1]]
cpx4 = [[1,1,1]]
cpx5 = []

reverse_order_filtration = [cpx1, cpx2, cpx3, cpx4, cpx5]
forward_order_filtration = [cpx5, cpx4, cpx3, cpx2, cpx1]

cpx00 = [[1,1,1,1]]
cpx01 = [[1,0,1,0],[1,1,0,1],[0,1,1,1]]
cpx02 = [[0,1,0,1],[1,0,1,0]]

fwd_2 = [cpx00, cpx01, cpx02]

def plot_trees_with_multiple_configurations(filtration, label=True, decomp_type='elementary'):
    fig, axes = plt.subplots(2,2)
    ax = axes.flatten()
    g1 = create_tree_3(filtration, label=label, directed=True, all_ideals=False, decomp_type=decomp_type, return_graph=True,
                       graph_type='inner_corners')
    g2 = create_tree_3(filtration, label=label, directed=True, all_ideals=False, decomp_type=decomp_type, return_graph=True,
                       graph_type='overlap')
    g3 = create_tree_3(filtration, label=label, directed=True, all_ideals=True, decomp_type=decomp_type, return_graph=True,
                       graph_type='inner_corners')
    g4 = create_tree_3(filtration, label=label, directed=True, all_ideals=True, decomp_type=decomp_type, return_graph=True,
                       graph_type='overlap')
    graphs = [g1, g2, g3, g4]
    for g in graphs:
        node_colors2 = [plt.cm.tab10(g.nodes[node]['blockindex']) for node in list(g.nodes())]
        # draw the graph
        #pos = nx.planar_layout(g)
        pos = nx.circular_layout(g)
        nodes = nx.draw_networkx_nodes(g, pos, node_color=node_colors2, ax=ax[graphs.index(g)])
        if label:
            labels = nx.draw_networkx_labels(g, pos, ax=ax[graphs.index(g)])
        edges = nx.draw_networkx_edges(
            g,
            pos,
            arrowstyle='-|>',
            arrowsize=10,
            width=1,
            ax=ax[graphs.index(g)]
        )
    plt.show()


# turns networkx (di)graph into a simplextree
def turn_graph_to_simplextree(graph):
    nodes = list(graph.nodes())
    edges = [list(edge) for edge in graph.edges()]
    new_edges = []
    for edge in edges:
        new_edges.append([nodes.index(edge[0]), nodes.index(edge[1])])
    simplextree = gudhi.SimplexTree()
    for edge in new_edges:
        simplextree.insert(list(edge))
    return simplextree


st = turn_graph_to_simplextree(create_tree_3(fwd_2, label=False, directed=True, all_ideals=True, decomp_type='elementary', return_graph=True))
#print(list(st.get_simplices()))
st.compute_persistence(persistence_dim_max=1)
print(st.betti_numbers())

#plot_trees_with_multiple_configurations(new_ideals, label=False, decomp_type='elementary')
#plot_trees_with_multiple_configurations(reverse_ideal_filtration, label=False, decomp_type='organized')
#create_tree_3(reverse_order_filtration, label=True, directed=True, all_ideals=True, decomp_type='elementary', return_graph=False)
#create_tree_3(new_ideals, label=True, directed=True, all_ideals=True, decomp_type='elementary', return_graph=False)
#plot_trees_with_multiple_configurations(new_ideals, label=False, decomp_type='elementary')
#plot_trees_with_multiple_configurations(forward_order_filtration, label=False, decomp_type='elementary')

#create_tree_2(reverse_order_filtration, label=True, directed=True, all_ideals=False, decomp_type='elementary')
#create_tree_3(reverse_order_filtration, label=True, directed=True, all_ideals=False, decomp_type='elementary')
#create_tree_2(reverse_order_filtration, label=True, directed=True, all_ideals=True, decomp_type='elementary')
#create_tree_3(forward_order_filtration, label=True, directed=True, all_ideals=True, decomp_type='elementary')

#create_tree_2([cpx1,cpx2,cpx3,cpx4, cpx5], label=True, directed=True, all_ideals=True, decomp_type='elementary')
#create_tree_2([cpx1,cpx2,cpx3,cpx4], label=True, directed=True, all_ideals=False, decomp_type='elementary')
#create_tree_2([cpx4,cpx3,cpx2,cpx1], label=True, directed=True, all_ideals=True, decomp_type='elementary')
#create_tree_3([cpx1,cpx2,cpx3,cpx4], label=True, directed=True, all_ideals=False, decomp_type='elementary')
#create_tree_3([cpx4,cpx3,cpx2,cpx1], label=True, directed=True, all_ideals=True, decomp_type='elementary')
#create_tree_2([cpx5,cpx4,cpx3,cpx2,cpx1], label=True, directed=True, all_ideals=True, decomp_type='organized')
#create_tree_2([cpx5,cpx4,cpx3,cpx2,cpx1], label=False, directed=True, all_ideals=False)

#create_tree_2([cpx00, cpx01, cpx02], label=True, directed=True)

#create_tree_2([ideal1, ideal2, ideal3], directed=True, label=True, sorting_order=(1,0), all_ideals=True)
#create_tree_2([ideal1, ideal2, ideal3], directed=True, label=True, sorting_order=(0,1), all_ideals=True)

#create_tree_2([ideal3, ideal2, ideal1], directed=True, label=True)

#print(elementary_decomposition(ideal3))
